# Telegraf Configuration for RTL_433 Weather Station Data

[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"
  precision = "1s"
  hostname = "weather-station"
  omit_hostname = false
  debug = true
  quiet = false
  logfile = ""
  logfile_rotation_max_size = "10MB"

###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Subscribe to MQTT topic for RTL_433 data
[[inputs.mqtt_consumer]]
  ## MQTT broker URLs
  servers = ["tcp://mosquitto:1883"]

  ## Topics to subscribe to
  ## Subscribe to specific device topics only (excludes /availability)
  topics = [
    "rtl_433/Vevor-7in1/+",
  ]

  ## QoS policy for messages
  qos = 0

  ## Connection timeout
  connection_timeout = "30s"

  ## Data format
  data_format = "json"

  ## Name suffix to track the topic
  topic_tag = "topic"

  ## Measurement name
  name_override = "rtl433"

  ## Extract tags from these JSON fields
  tag_keys = ["model", "id", "channel", "battery_ok", "mic", "mod"]

  ## Parse timestamp from JSON
  json_time_key = "time"
  json_time_format = "2006-01-02 15:04:05"
  json_timezone = "$TZ"

  ## String fields (non-numeric)
  json_string_fields = ["model", "mic", "mod", "subtype", "raw_msg"]

  ## Filter: Only accept metrics with mod="FSK" (ignore ASK interference)
  [inputs.mqtt_consumer.tagpass]
    mod = ["FSK"]

###############################################################################
#                           PROCESSOR PLUGINS                                 #
###############################################################################

[[processors.starlark]]
  namepass = ["rtl433"]

  source = '''
# Load required libraries
load("math.star", "math")

def apply(metric):
    # Extract current values
    temp_c = metric.fields.get("temperature_C", 0.0)
    humidity = metric.fields.get("humidity", 50)
    wind_km_h = metric.fields.get("wind_avg_km_h", 0.0)
    light_lux = metric.fields.get("light_lux", 0.0)
    uvi = metric.fields.get("uvi", 0.0)
    battery_ok = metric.fields.get("battery_ok", 1)

    # ========== 1. DEW POINT (Magnus Formula) ==========
    # Formula: Td = (c * gamma) / (b - gamma)
    # where gamma = (b * T / (c + T)) + ln(RH/100)
    # Constants: b = 17.625, c = 243.04°C
    b = 17.625
    c = 243.04

    if humidity > 0 and humidity <= 100:
        gamma = (b * temp_c / (c + temp_c)) + math.log(humidity / 100.0)
        dew_point_c = (c * gamma) / (b - gamma)
    else:
        dew_point_c = temp_c  # Fallback if humidity invalid

    metric.fields["dew_point_C"] = dew_point_c

    # ========== 2. FEELS LIKE TEMPERATURE ==========
    # Context-aware:
    # - Wind chill: temp < 10°C AND wind > 4.8 km/h
    # - Heat index: temp > 27°C AND humidity > 40%
    # - Otherwise: actual temperature

    feels_like_c = temp_c  # Default

    # Wind Chill (Celsius formula)
    # WC = 13.12 + 0.6215*T - 11.37*V^0.16 + 0.3965*T*V^0.16
    if temp_c < 10.0 and wind_km_h > 4.8:
        v_power = math.pow(wind_km_h, 0.16)
        feels_like_c = 13.12 + (0.6215 * temp_c) - (11.37 * v_power) + (0.3965 * temp_c * v_power)

    # Heat Index (approximation for Celsius)
    # Simplified Rothfusz formula adapted to Celsius
    elif temp_c > 27.0 and humidity > 40:
        T = temp_c
        RH = humidity
        c1 = -8.78469475556
        c2 = 1.61139411
        c3 = 2.33854883889
        c4 = -0.14611605
        c5 = -0.012308094
        c6 = -0.0164248277778
        c7 = 0.002211732
        c8 = 0.00072546
        c9 = -0.000003582

        feels_like_c = (c1 + (c2 * T) + (c3 * RH) + (c4 * T * RH) +
                       (c5 * T * T) + (c6 * RH * RH) +
                       (c7 * T * T * RH) + (c8 * T * RH * RH) +
                       (c9 * T * T * RH * RH))

    metric.fields["feels_like_C"] = feels_like_c

    # ========== 3. SOLAR RADIATION ==========
    # Approximation: Solar radiation (W/m²) ≈ lux / 126.7
    solar_radiation = light_lux / 126.7
    metric.fields["solar_radiation_w_m2"] = solar_radiation

    # ========== 4. BEAUFORT SCALE ==========
    # Wind speed to Beaufort scale (0-12)
    # Based on wind_avg_km_h
    beaufort = 0
    if wind_km_h < 1.0:
        beaufort = 0
    elif wind_km_h < 5.5:
        beaufort = 1
    elif wind_km_h < 11.9:
        beaufort = 2
    elif wind_km_h < 19.8:
        beaufort = 3
    elif wind_km_h < 28.7:
        beaufort = 4
    elif wind_km_h < 38.8:
        beaufort = 5
    elif wind_km_h < 49.9:
        beaufort = 6
    elif wind_km_h < 61.8:
        beaufort = 7
    elif wind_km_h < 74.6:
        beaufort = 8
    elif wind_km_h < 88.1:
        beaufort = 9
    elif wind_km_h < 102.4:
        beaufort = 10
    elif wind_km_h < 117.4:
        beaufort = 11
    else:
        beaufort = 12

    metric.fields["wind_speed_beaufort"] = float(beaufort)

    # ========== 5. UV RISK LEVEL ==========
    # Map UVI to risk category (stored as numeric for easier querying)
    # 0 = Low, 1 = Moderate, 2 = High, 3 = Very High, 4 = Extreme
    uv_risk = 0
    if uvi < 3:
        uv_risk = 0  # Low
    elif uvi < 6:
        uv_risk = 1  # Moderate
    elif uvi < 8:
        uv_risk = 2  # High
    elif uvi < 11:
        uv_risk = 3  # Very High
    else:
        uv_risk = 4  # Extreme

    metric.fields["uv_risk_level"] = float(uv_risk)

    # ========== 6. BATTERY STATUS ==========
    # Convert battery_ok (1/0) to percentage
    # Assuming: 1 = 100%, 0 = 0% (simple binary)
    battery_pct = 100.0 if battery_ok == 1 else 0.0
    metric.fields["battery_status_pct"] = battery_pct

    return metric
'''

###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################

# Write to InfluxDB 2.x
[[outputs.influxdb_v2]]
  ## InfluxDB URL
  urls = ["http://influxdb:8086"]

  ## Token for authentication
  token = "$INFLUXDB_ADMIN_TOKEN"

  ## Organization
  organization = "$INFLUXDB_ORG"

  ## Destination bucket
  bucket = "$INFLUXDB_BUCKET"

  ## Timeout for HTTP messages
  timeout = "5s"

# Optional: Output to console for debugging (comment out in production)
# [[outputs.file]]
#   files = ["stdout"]
#   data_format = "influx"
