# Telegraf Configuration for RTL_433 Weather Station Data

[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"
  precision = "1s"
  hostname = ""
  omit_hostname = false
  debug = true
  quiet = false
  logfile = ""
  logfile_rotation_max_size = "10MB"

###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Subscribe to MQTT topic for RTL_433 data
[[inputs.mqtt_consumer]]
  ## MQTT broker URLs
  servers = ["tcp://mosquitto:1883"]

  ## Topics to subscribe to
  ## Subscribe to specific device topics only (excludes /availability)
  topics = [
    "rtl_433/Vevor-7in1/+",
  ]

  ## QoS policy for messages
  qos = 0

  ## Connection timeout
  connection_timeout = "30s"

  ## Data format
  data_format = "json"

  ## Name suffix to track the topic
  topic_tag = "topic"

  ## Measurement name
  name_override = "rtl433"

  ## Extract tags from these JSON fields
  tag_keys = ["model", "id", "channel", "battery_ok", "mic", "mod"]

  ## Parse timestamp from JSON
  json_time_key = "time"
  json_time_format = "2006-01-02 15:04:05"
  json_timezone = "$TZ"

  ## String fields (non-numeric)
  json_string_fields = ["model", "mic", "mod", "subtype", "raw_msg"]

  ## Filter: Only accept metrics with mod="FSK" (ignore ASK interference)
  [inputs.mqtt_consumer.tagpass]
    mod = ["FSK"]

###############################################################################
#                           PROCESSOR PLUGINS                                 #
###############################################################################

[[processors.starlark]]
  namepass = ["rtl433"]

  source = '''
# Load required libraries
load("math.star", "math")
load("time.star", "time")

# State management for daily rain and precipitation rate
# state persists across metric processing calls
state = {}

def apply(metric):
    # Extract current values
    temp_c = metric.fields.get("temperature_C", 0.0)
    humidity = metric.fields.get("humidity", 50)
    wind_km_h = metric.fields.get("wind_avg_km_h", 0.0)
    rain_mm = metric.fields.get("rain_mm", 0.0)
    light_lux = metric.fields.get("light_lux", 0.0)
    uvi = metric.fields.get("uvi", 0.0)
    battery_ok = metric.fields.get("battery_ok", 1)

    # Get current timestamp in Europe/Madrid timezone
    timestamp_ns = metric.time
    timestamp_s = int(timestamp_ns / 1000000000)

    # Parse time in local timezone (from TZ environment variable)
    # Note: Starlark doesn't support dynamic timezone detection
    # IMPORTANT: This offset must match your TZ setting in .env
    # - For Europe/Madrid (winter UTC+1): use 3600
    # - For Europe/Madrid (summer UTC+2): use 7200
    # - For US Eastern (winter UTC-5): use -18000
    # - For US Eastern (summer UTC-4): use -14400
    # This ensures midnight detection works correctly in local timezone
    tz_offset = 3600  # UTC+1 for Europe/Madrid winter - adjust for DST manually
    dt = time.from_timestamp(timestamp_s + tz_offset)

    # Format date as YYYY-MM-DD (Starlark format doesn't support padding specs)
    year_str = str(dt.year)
    month_str = str(dt.month) if dt.month >= 10 else "0" + str(dt.month)
    day_str = str(dt.day) if dt.day >= 10 else "0" + str(dt.day)
    current_date = year_str + "-" + month_str + "-" + day_str

    # ========== 1. DEW POINT (Magnus Formula) ==========
    # Formula: Td = (c * gamma) / (b - gamma)
    # where gamma = (b * T / (c + T)) + ln(RH/100)
    # Constants: b = 17.625, c = 243.04°C
    b = 17.625
    c = 243.04

    if humidity > 0 and humidity <= 100:
        gamma = (b * temp_c / (c + temp_c)) + math.log(humidity / 100.0)
        dew_point_c = (c * gamma) / (b - gamma)
    else:
        dew_point_c = temp_c  # Fallback if humidity invalid

    metric.fields["dew_point_C"] = dew_point_c

    # ========== 2. FEELS LIKE TEMPERATURE ==========
    # Context-aware:
    # - Wind chill: temp < 10°C AND wind > 4.8 km/h
    # - Heat index: temp > 27°C AND humidity > 40%
    # - Otherwise: actual temperature

    feels_like_c = temp_c  # Default

    # Wind Chill (Celsius formula)
    # WC = 13.12 + 0.6215*T - 11.37*V^0.16 + 0.3965*T*V^0.16
    if temp_c < 10.0 and wind_km_h > 4.8:
        v_power = math.pow(wind_km_h, 0.16)
        feels_like_c = 13.12 + (0.6215 * temp_c) - (11.37 * v_power) + (0.3965 * temp_c * v_power)

    # Heat Index (approximation for Celsius)
    # Simplified Rothfusz formula adapted to Celsius
    elif temp_c > 27.0 and humidity > 40:
        T = temp_c
        RH = humidity
        c1 = -8.78469475556
        c2 = 1.61139411
        c3 = 2.33854883889
        c4 = -0.14611605
        c5 = -0.012308094
        c6 = -0.0164248277778
        c7 = 0.002211732
        c8 = 0.00072546
        c9 = -0.000003582

        feels_like_c = (c1 + (c2 * T) + (c3 * RH) + (c4 * T * RH) +
                       (c5 * T * T) + (c6 * RH * RH) +
                       (c7 * T * T * RH) + (c8 * T * RH * RH) +
                       (c9 * T * T * RH * RH))

    metric.fields["feels_like_C"] = feels_like_c

    # ========== 3. DAILY RAIN TRACKING ==========
    # Two variables:
    # - daily_rain_total: Final total from previous complete day (for long-term stats)  
    # - daily_rain_current: Accumulating during current day, resets at midnight

    # Initialize state on first run
    if "last_date" not in state:
        state["last_date"] = current_date
        state["daily_rain_start"] = rain_mm
        state["daily_rain_total"] = 0.0

    # Check if day changed (midnight reset)
    if current_date != state["last_date"]:
        # New day detected - finalize previous day's total and reset for new day
        prev_day_total = rain_mm - state["daily_rain_start"]
        if prev_day_total >= 0:  # Only update if sensible value
            state["daily_rain_total"] = prev_day_total
        
        # Reset daily tracking for new day
        state["daily_rain_start"] = rain_mm
        state["last_date"] = current_date

    # Calculate current day's accumulation
    daily_rain_current = rain_mm - state["daily_rain_start"]

    # Handle sensor reset (rain_mm decreases unexpectedly or goes negative)
    if daily_rain_current < 0:
        # Sensor was reset - restart daily tracking from current value
        state["daily_rain_start"] = rain_mm
        daily_rain_current = 0.0

    # Ensure reasonable values (sensor sometimes gives spikes)
    if daily_rain_current > 1000:  # More than 1 meter of rain per day is unrealistic
        state["daily_rain_start"] = rain_mm
        daily_rain_current = 0.0

    metric.fields["daily_rain_total"] = state.get("daily_rain_total", 0.0)
    metric.fields["daily_rain_current"] = daily_rain_current

    # ========== 4. PRECIPITATION RATE (5-minute window) ==========
    # Track rain change over 5 minutes to calculate mm/hour rate

    if "prev_rain_mm" not in state:
        state["prev_rain_mm"] = rain_mm
        state["prev_rain_time"] = timestamp_s
        state["last_precip_rate"] = 0.0
        metric.fields["precipitation_rate_mm_h"] = 0.0
    else:
        time_diff_s = timestamp_s - state["prev_rain_time"]

        # Only calculate if at least 5 minutes have passed (300 seconds)
        if time_diff_s >= 300:
            rain_diff_mm = rain_mm - state["prev_rain_mm"]

            # Handle sensor reset
            if rain_diff_mm < 0:
                rain_diff_mm = 0.0

            # Convert to mm/hour: (mm change) / (seconds) * 3600
            if time_diff_s > 0:
                precip_rate = (rain_diff_mm / time_diff_s) * 3600.0
            else:
                precip_rate = 0.0

            metric.fields["precipitation_rate_mm_h"] = precip_rate
            state["last_precip_rate"] = precip_rate

            # Update state
            state["prev_rain_mm"] = rain_mm
            state["prev_rain_time"] = timestamp_s
        else:
            # Use last calculated rate if time window hasn't passed
            metric.fields["precipitation_rate_mm_h"] = state.get("last_precip_rate", 0.0)

    # ========== 5. SOLAR RADIATION ==========
    # Approximation: Solar radiation (W/m²) ≈ lux / 126.7
    solar_radiation = light_lux / 126.7
    metric.fields["solar_radiation_w_m2"] = solar_radiation

    # ========== 6. BEAUFORT SCALE ==========
    # Wind speed to Beaufort scale (0-12)
    # Based on wind_avg_km_h
    beaufort = 0
    if wind_km_h < 1.0:
        beaufort = 0
    elif wind_km_h < 5.5:
        beaufort = 1
    elif wind_km_h < 11.9:
        beaufort = 2
    elif wind_km_h < 19.8:
        beaufort = 3
    elif wind_km_h < 28.7:
        beaufort = 4
    elif wind_km_h < 38.8:
        beaufort = 5
    elif wind_km_h < 49.9:
        beaufort = 6
    elif wind_km_h < 61.8:
        beaufort = 7
    elif wind_km_h < 74.6:
        beaufort = 8
    elif wind_km_h < 88.1:
        beaufort = 9
    elif wind_km_h < 102.4:
        beaufort = 10
    elif wind_km_h < 117.4:
        beaufort = 11
    else:
        beaufort = 12

    metric.fields["wind_speed_beaufort"] = float(beaufort)

    # ========== 7. UV RISK LEVEL ==========
    # Map UVI to risk category (stored as numeric for easier querying)
    # 0 = Low, 1 = Moderate, 2 = High, 3 = Very High, 4 = Extreme
    uv_risk = 0
    if uvi < 3:
        uv_risk = 0  # Low
    elif uvi < 6:
        uv_risk = 1  # Moderate
    elif uvi < 8:
        uv_risk = 2  # High
    elif uvi < 11:
        uv_risk = 3  # Very High
    else:
        uv_risk = 4  # Extreme

    metric.fields["uv_risk_level"] = float(uv_risk)

    # ========== 8. BATTERY STATUS ==========
    # Convert battery_ok (1/0) to percentage
    # Assuming: 1 = 100%, 0 = 0% (simple binary)
    battery_pct = 100.0 if battery_ok == 1 else 0.0
    metric.fields["battery_status_pct"] = battery_pct

    return metric
'''

###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################

# Write to InfluxDB 2.x
[[outputs.influxdb_v2]]
  ## InfluxDB URL
  urls = ["http://influxdb:8086"]

  ## Token for authentication
  token = "$INFLUXDB_ADMIN_TOKEN"

  ## Organization
  organization = "$INFLUXDB_ORG"

  ## Destination bucket
  bucket = "$INFLUXDB_BUCKET"

  ## Timeout for HTTP messages
  timeout = "5s"

# Optional: Output to console for debugging (comment out in production)
# [[outputs.file]]
#   files = ["stdout"]
#   data_format = "influx"
