# Telegraf Configuration for RTL_433 Weather Station Data

[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"
  precision = "1s"
  hostname = "weather-station"
  omit_hostname = false
  debug = true
  quiet = false
  logfile = ""
  logfile_rotation_max_size = "10MB"

###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Subscribe to MQTT topic for RTL_433 data
[[inputs.mqtt_consumer]]
  ## MQTT broker URLs
  servers = ["tcp://mosquitto:1883"]

  ## Topics to subscribe to
  ## Subscribe to specific device topics only (excludes /availability)
  topics = [
    "rtl_433/Vevor-7in1/+",
  ]

  ## QoS policy for messages
  qos = 0

  ## Connection timeout
  connection_timeout = "30s"

  ## Data format
  data_format = "json"

  ## Name suffix to track the topic
  topic_tag = "topic"

  ## Measurement name
  name_override = "rtl433"

  ## Extract tags from these JSON fields
  tag_keys = ["model", "id", "channel", "battery_ok", "mic", "mod"]

  ## Parse timestamp from JSON
  json_time_key = "time"
  json_time_format = "2006-01-02 15:04:05"
  json_timezone = "$TZ"

  ## String fields (non-numeric)
  json_string_fields = ["model", "mic", "mod", "subtype", "raw_msg"]

  ## Filter: Only accept metrics with mod="FSK" (ignore ASK interference)
  [inputs.mqtt_consumer.tagpass]
    mod = ["FSK"]

###############################################################################
#                           PROCESSOR PLUGINS                                 #
###############################################################################

[[processors.starlark]]
  namepass = ["rtl433"]

  source = '''
# Load required libraries
load("math.star", "math")
load("time.star", "time")

# State management for daily rain and precipitation rate
# state persists across metric processing calls
state = {}

def apply(metric):
    # Extract current values
    temp_c = metric.fields.get("temperature_C", 0.0)
    humidity = metric.fields.get("humidity", 50)
    wind_km_h = metric.fields.get("wind_avg_km_h", 0.0)
    rain_mm = metric.fields.get("rain_mm", 0.0)
    light_lux = metric.fields.get("light_lux", 0.0)
    uvi = metric.fields.get("uvi", 0.0)
    battery_ok = metric.fields.get("battery_ok", 1)

    # Get current timestamp and calculate timezone offset dynamically
    timestamp_ns = metric.time
    timestamp_s = int(timestamp_ns / 1000000000)
    
    # Dynamic timezone offset based on TZ environment variable
    # For Europe/Madrid: +1 (winter) / +2 (summer)
    # This is a simplified approach - for production, use proper timezone libraries
    tz_env = "$TZ"  # e.g., "Europe/Madrid"
    
    # Simplified DST detection for Europe/Madrid (adjust for other zones)
    # Use proper timezone conversion instead of manual DST calculation
    # Let the system handle DST transitions properly
    dt_utc = time.from_timestamp(timestamp_s)
    dt = time.from_timestamp(timestamp_s)  # This will use container's TZ setting
    
    # Alternative: If we need explicit timezone handling, use the container's TZ
    # Since container is set to Europe/Madrid, time.from_timestamp() should work correctly

    # Format date as YYYY-MM-DD
    year_str = str(dt.year)
    month_str = str(dt.month) if dt.month >= 10 else "0" + str(dt.month)
    day_str = str(dt.day) if dt.day >= 10 else "0" + str(dt.day)
    current_date = year_str + "-" + month_str + "-" + day_str

    # ========== 1. DEW POINT (Magnus Formula) ==========
    # Formula: Td = (c * gamma) / (b - gamma)
    # where gamma = (b * T / (c + T)) + ln(RH/100)
    # Constants: b = 17.625, c = 243.04°C
    b = 17.625
    c = 243.04

    if humidity > 0 and humidity <= 100:
        gamma = (b * temp_c / (c + temp_c)) + math.log(humidity / 100.0)
        dew_point_c = (c * gamma) / (b - gamma)
    else:
        dew_point_c = temp_c  # Fallback if humidity invalid

    metric.fields["dew_point_C"] = dew_point_c

    # ========== 2. FEELS LIKE TEMPERATURE ==========
    # Context-aware:
    # - Wind chill: temp < 10°C AND wind > 4.8 km/h
    # - Heat index: temp > 27°C AND humidity > 40%
    # - Otherwise: actual temperature

    feels_like_c = temp_c  # Default

    # Wind Chill (Celsius formula)
    # WC = 13.12 + 0.6215*T - 11.37*V^0.16 + 0.3965*T*V^0.16
    if temp_c < 10.0 and wind_km_h > 4.8:
        v_power = math.pow(wind_km_h, 0.16)
        feels_like_c = 13.12 + (0.6215 * temp_c) - (11.37 * v_power) + (0.3965 * temp_c * v_power)

    # Heat Index (approximation for Celsius)
    # Simplified Rothfusz formula adapted to Celsius
    elif temp_c > 27.0 and humidity > 40:
        T = temp_c
        RH = humidity
        c1 = -8.78469475556
        c2 = 1.61139411
        c3 = 2.33854883889
        c4 = -0.14611605
        c5 = -0.012308094
        c6 = -0.0164248277778
        c7 = 0.002211732
        c8 = 0.00072546
        c9 = -0.000003582

        feels_like_c = (c1 + (c2 * T) + (c3 * RH) + (c4 * T * RH) +
                       (c5 * T * T) + (c6 * RH * RH) +
                       (c7 * T * T * RH) + (c8 * T * RH * RH) +
                       (c9 * T * T * RH * RH))

    metric.fields["feels_like_C"] = feels_like_c

    # ========== 3. SIMPLIFIED RAIN TRACKING ==========
    # RESTART-RESILIENT APPROACH:
    # - On restart, we lose in-memory state but can be conservative
    # - Daily rain resets to 0 on restart (most accurate approach)  
    # - State persists during normal operation
    # - Sensor reset detection maintains continuity
    
    # Initialize state 
    if "rain_daily_start" not in state:
        state["rain_daily_start"] = rain_mm
        state["current_date"] = current_date
        state["highest_rain_mm"] = rain_mm
        state["prev_rain_mm"] = rain_mm  
        state["prev_rain_time"] = timestamp_s
        state["last_precip_rate"] = 0.0
    
    # ========== SENSOR GLITCH FILTERING ==========
    # Handle temporary sensor glitches (short-term drops and recoveries)
    time_diff = timestamp_s - state["prev_rain_time"]
    rain_diff = rain_mm - state["prev_rain_mm"]
    
    # If rain_mm jumps up dramatically in a short time, it might be recovering from a glitch
    if time_diff > 0 and time_diff < 300 and rain_diff > 30:  # >30mm in <5min is suspicious
        # Check if this looks like a recovery from a temporary drop
        # Keep the daily rain stable during glitch recovery
        current_daily = state["prev_rain_mm"] - state["rain_daily_start"]
        if current_daily >= 0 and current_daily < 200:  # If previous daily was reasonable
            # Adjust baseline to maintain consistent daily value
            state["rain_daily_start"] = rain_mm - current_daily
    
    # Check for new day (midnight reset)
    if current_date != state["current_date"]:
        # New day: reset daily rain tracking
        state["rain_daily_start"] = rain_mm
        state["current_date"] = current_date
    
    # Detect sensor reset (rain_mm dropped significantly from highest seen)
    if rain_mm < state["highest_rain_mm"] - 50:  # 50mm threshold
        # Sensor was reset - maintain daily accumulation continuity
        daily_before_reset = state["highest_rain_mm"] - state["rain_daily_start"]
        state["rain_daily_start"] = rain_mm - max(0, daily_before_reset)
        state["highest_rain_mm"] = rain_mm
    
    # Update highest rain value seen (for reset detection)
    if rain_mm > state["highest_rain_mm"]:
        state["highest_rain_mm"] = rain_mm
    
    # Calculate daily rain
    daily_rain_current = rain_mm - state["rain_daily_start"]
    
    # Sanity checks
    if daily_rain_current < 0:
        state["rain_daily_start"] = rain_mm
        daily_rain_current = 0.0
    elif daily_rain_current > 300:  # 300mm/day is extreme
        state["rain_daily_start"] = rain_mm
        daily_rain_current = 0.0

    metric.fields["daily_rain_current"] = daily_rain_current

    # ========== 4. PRECIPITATION RATE (5-minute window) ==========
    time_diff_s = timestamp_s - state["prev_rain_time"]
    
    if time_diff_s >= 300:  # 5 minutes
        rain_diff_mm = rain_mm - state["prev_rain_mm"]
        
        # Handle sensor reset in rate calculation
        if rain_diff_mm < 0:
            rain_diff_mm = 0.0
        
        # Convert to mm/hour
        precip_rate = (rain_diff_mm / time_diff_s) * 3600.0 if time_diff_s > 0 else 0.0
        
        metric.fields["precipitation_rate_mm_h"] = precip_rate
        
        # Update state
        state["prev_rain_mm"] = rain_mm
        state["prev_rain_time"] = timestamp_s
        state["last_precip_rate"] = precip_rate
    else:
        # Use last rate until next 5-minute window
        metric.fields["precipitation_rate_mm_h"] = state["last_precip_rate"]

    # ========== 5. SOLAR RADIATION ==========
    # Approximation: Solar radiation (W/m²) ≈ lux / 126.7
    solar_radiation = light_lux / 126.7
    metric.fields["solar_radiation_w_m2"] = solar_radiation

    # ========== 6. BEAUFORT SCALE ==========
    # Wind speed to Beaufort scale (0-12)
    # Based on wind_avg_km_h
    beaufort = 0
    if wind_km_h < 1.0:
        beaufort = 0
    elif wind_km_h < 5.5:
        beaufort = 1
    elif wind_km_h < 11.9:
        beaufort = 2
    elif wind_km_h < 19.8:
        beaufort = 3
    elif wind_km_h < 28.7:
        beaufort = 4
    elif wind_km_h < 38.8:
        beaufort = 5
    elif wind_km_h < 49.9:
        beaufort = 6
    elif wind_km_h < 61.8:
        beaufort = 7
    elif wind_km_h < 74.6:
        beaufort = 8
    elif wind_km_h < 88.1:
        beaufort = 9
    elif wind_km_h < 102.4:
        beaufort = 10
    elif wind_km_h < 117.4:
        beaufort = 11
    else:
        beaufort = 12

    metric.fields["wind_speed_beaufort"] = float(beaufort)

    # ========== 7. UV RISK LEVEL ==========
    # Map UVI to risk category (stored as numeric for easier querying)
    # 0 = Low, 1 = Moderate, 2 = High, 3 = Very High, 4 = Extreme
    uv_risk = 0
    if uvi < 3:
        uv_risk = 0  # Low
    elif uvi < 6:
        uv_risk = 1  # Moderate
    elif uvi < 8:
        uv_risk = 2  # High
    elif uvi < 11:
        uv_risk = 3  # Very High
    else:
        uv_risk = 4  # Extreme

    metric.fields["uv_risk_level"] = float(uv_risk)

    # ========== 8. BATTERY STATUS ==========
    # Convert battery_ok (1/0) to percentage
    # Assuming: 1 = 100%, 0 = 0% (simple binary)
    battery_pct = 100.0 if battery_ok == 1 else 0.0
    metric.fields["battery_status_pct"] = battery_pct

    return metric
'''

###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################

# Write to InfluxDB 2.x
[[outputs.influxdb_v2]]
  ## InfluxDB URL
  urls = ["http://influxdb:8086"]

  ## Token for authentication
  token = "$INFLUXDB_ADMIN_TOKEN"

  ## Organization
  organization = "$INFLUXDB_ORG"

  ## Destination bucket
  bucket = "$INFLUXDB_BUCKET"

  ## Timeout for HTTP messages
  timeout = "5s"

# Optional: Output to console for debugging (comment out in production)
# [[outputs.file]]
#   files = ["stdout"]
#   data_format = "influx"
